## Performance

Note:
Something that React is often accociated with React is performance.

---

![myths](../../images/myths.jpg)<!-- .element: width="800" -->

Note:
A common misconception that bothers me a bit, is that React is somehow magically faster than all other libraries, because of the virtual DOM.

Which is simply not true.

I think the way React is architected leads to good perfomance out of the box. And it's API offers some simple ways to optimise performance.

Applying changes against a virtual DOM, and then deferring to React's reconcilliation alogrithm means that you don't need to do the heavy lifting of figuring out how to update the DOM efficienty, and it and means you avoid being chatty with the DOM. Effectively "double buffering" changes.

So it's easier to build applications that are fast, but performance will generally be comparable to other frameworks (such as Anguar and Ember) if they are optimised well.

Testament to this is the fact that we haven't got to the stage where we've heavily needed to improve performance in the app, and it's remained at mostly acceptable levels of performance. We've still got quite a bit of work in that are in front of us.

---

## Provide stable keys

---


<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/stable-keys.js"><img src="../../images/stable-keys.png" style="margin-top: -60px; border: 0;" /></a>

Note:
A simple performamce tip, which React will actually warn you about in the console is to make sure you're providing _stable_ keys for your components, especially lists of components mapped from arrays.

This helps React when reconciling the DOM.


---

## Avoiding reconciling the DOM
<img src="../../images/../../images/reconciliation.png" style="" width="800" />

Note:
Whilst React is pretty smart about the way it reconciles it's virtual DOM with the real one, the main performance optimisation technique is to give React hints to reduce the amount of reconciliation it needs to do at all.


---

## `shouldComponentUpdate`

Note:

This is done by using the shouldComponentUpdate hook in the component lifecycle. This is called before the rendering process starts, giving you the opportunity to shortcut the process.

---

<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/should-component-update.coffee"><img src="../../images/should-component-update.png" style="margin-top: -60px; border: 0;" /></a>


Note:
Here you can check if the props or state of a component have changed in a way that effects what will be rendered. If not, return false to shortcut the rendering entirely.

---

## `PureRenderMixin`

---

<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/pure-render.js"><img src="../../images/pure-render.png" style="margin-top: -60px; border: 0;" /></a>

Note:
For situations where the rendering us _just_ based on simple shallow props and states values, Facebook provides a generalised solution to this problem via the PureRenderMixin. This hooks shouldComponentUpdate and does a shallow comparison of all props and state.

The situation is a little more complicated with nested data structures such as arrays and lists. A top level comparison like this will always return true even if the contents have changes.

---


## Immutable Data

Note:
This is where immutable data structures can help. Essentially these are structures allow you to change only what is necessary in nested structures.

---

<img src="../../images/../../images/immutable-structure.png" width="800" />

Note:
I'll intentionally gloss over the details since it's a fairly dense subject,  but essentially they efficiently allow you to determine only what's changed in nested data structures, so a shouldComponentUpdate checks are simple even for reference data.

---

## Immutable Libraries

<img src="../../images/../../images/immutble-helpers.png" style="border: 0; float: left;" width="450" />
<img src="../../images/../../images/immutable-js.png" style="border: 0; float: right;" width="450" />

Note:
Facebook offers some simple immutable helpers as part of it's addons, and they've released a much more fully feaurted standalone immutable-js library.

We've experimented with both of these in the app, and we've still got a fair bit of optimisation to do.

Whilst they're very clever and their concepts are great. But they do come with an overhead, making code that updates data more complicated.

Our current approach is to identify the performance hot-spots within the app, and optimise those with immutable-js if appropriate.


---

## React performance tools
- `Perf.start()` & `Perf.stop()`
- `Perf.printInclusive(measurements)`
- `Perf.printExclusive(measurements)`
- `Perf.printWasted(measurements)`

Note:
React comes with a neat Addon to help you figure out where these performance hotspots are.

It's a pretty simple API that let's you start and stop recording of react operations for analysis, and then print the results.

The most important call this is the printWasted command, which shows you time spend rendering and reconcillling components that didn't result in any actual DOM updates. I.e. the components that would benefit from implementing shouldComponentUpdate.

---

<img src="../../images/../../images/get-wasted.png" style="border: 0; margin-top: -50px;" width="1000" />

Note:
This is what the result looked like a few months ago with Atomic. 

It's probably a bit hard to make out, but the printWasted command shows you in the console which components are wasting most time with redundant rendering, and are good candidates for implementing shouldComponentUpdate.
