## Reuse

Note:
Since components are intended to be self-conatained and discrete, they naturally pull you towards reuse.

---

### `propTypes` & `getDefaultProps`

<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/proptypes.js">![proptypes](../../images/proptypes.png)<!-- .element: width="800" --></a>

Note:
To help with this, React let's you define a schema to validate the props that are passed to a component using propTypes, and set some default values. If create a component with the wrong type of props, a warning is logged to console.

Initially these seemed redundant, since we weren't interested in a type system.

But as our app as grown, we've started to find them useful, both in terms of helping think about a data contract upfront, and catching type issues early.

---

### Mixins
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/mixin.js">![proptypes](../../images/mixin.png)<!-- .element: width="800" --></a>

Note:
Something else that helps with re-use is mixins.

These mixins are simple modules that can access a components state, and hook into a components lifecycle, that are useful for capturing cross-cutting concerns. 

Here we see one that set's a components state in response to change events from a Store.

---

### Mixins
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/mixin-use.js">![proptypes](../../images/mixin-use.png)<!-- .element: width="800" --></a>

Note:
These mixins are then simply referenced in the definition of the component that needs to access them.

These _seem_ to be falling out of favour with the React team, as it tries to remove some internal magic from the library in favour of native ES6 constructs. 

We're still using them, but we're considering alternative approaches before creating new ones.

---


### Higher order components
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/higher-order-component.js">![proptypes](../../images/higher-order-component.png)<!-- .element: width="800" --></a>

Note:
An alternate approach that we've come across and started to experiment with is higher order components.

A higher-order component is just a function that takes an existing component and returns another component that wraps it.

It looks a lot like the mixin, but instead of managing the component’s internal state, it wraps the component and passes some additional props to it. This way wrapper’s lifecycle hooks work without any special merging behavior, by the virtue of simple component nesting!


---


### Higher order components
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/higher-order-component-use.js">![proptypes](../../images/higher-order-component-use.png)<!-- .element: width="800" --></a>

Note:
It is then used like this.

It's elegant, and reminds me very much of the decorator pattern. It does have a couple of trade-offs — wrapping components with multiple concerns becomes difficult, and these higher order components can't (by default) don't have access to a components state, and so require you to add a property layer.

---


### Inheritence
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/inheritence.js">![proptypes](../../images/inheritence.png)<!-- .element: width="800" --></a>

Note:

Finally, since Components can be declared as Classes, there's always good old fasioned inheritence. We don't really use inheritence. Does anyone any more?
