## Reuse

---

### propTypes & getDefaultProps()

<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/proptypes.js">![proptypes](../../images/proptypes.png)<!-- .element: width="800" --></a>

Note:
Since components are intended to be self-conatained and discrete, they naturally push you towards reuse.

To help with this, React let's you define a schema to validate the properties that are passed to a component using propTypes, and set some default values, and logs a warning to the console in development when the schema is invalidated.

Initially these seemed redundant, and an attempt to drag me from hipster dynamic-language-land back to the corporate world of static typing. 

But we've since come to appreciate the structure they provide both upfront in terms of forcing you to think about the data-contract a component has, and as you scale your app to catch type issues early. We've now got linter rules that force you to declare them.

---

### Mixins
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/mixin.js">![proptypes](../../images/mixin.png)<!-- .element: width="800" --></a>

Note:
React allows you to define Mixins to let you capture cross-cutting concerns. 
This mixins are simple modules that can access a components state, and hook into a components lifecycle. 

We see one here hooks into componentDidMount to register a shake listener, and cleans up on unMount.

---

### Mixins
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/mixin-use.js">![proptypes](../../images/mixin-use.png)<!-- .element: width="800" --></a>

Note:
These mixins are then simply referenced in the definition of the component that needs to access them.

These _seem_ to be falling out of favour with the React, as it tries to remove some internal magic from the library in favour of native ES6 constructs. 

We're still using them, but we're considering alternative approaches before creating new ones.

---


### Higher Order Components
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/higher-order-component.js">![proptypes](../../images/higher-order-component.png)<!-- .element: width="800" --></a>

Note:
An alternate approach that we've come across and started to experiment with is higher order components.

A higher-order component is just a function that takes an existing component and returns another component that wraps it.

It looks a lot like the mixin, but instead of managing the component’s internal state, it wraps the component and passes some additional props to it. This way wrapper’s lifecycle hooks work without any special merging behavior, by the virtue of simple component nesting!


---


### Higher Order Components
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/higher-order-component-use.js">![proptypes](../../images/higher-order-component-use.png)<!-- .element: width="800" --></a>

Note:
It is then used like this.

It's elegant, and reminds me very much of the decorator pattern. It does have a couple of trade-offs — wrapping components with multiple concerns becomes difficult, and these higher order components can't (by default) don't have access to a components state, and so require you to add a property layer.

A future option is this direction is native ES7 decorators of course.


---


### Higher Order Components
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/higher-order-component-use.js">![proptypes](../../images/higher-order-component-use.png)<!-- .element: width="800" --></a>

Note:
https://facebook.github.io/react/docs/reusable-components.html


---

### Inheritence
<a href="subl://open?url=file:///Users/vim/code/sketches/wdcnz-2015-react-tips-and-tricks/code-samples/inheritence.js">![proptypes](../../images/inheritence.png)<!-- .element: width="800" --></a>

Note:

Finally, since Components can be declared as Classes, there's always good old fasioned inheritence. We don't really use inheritence. Does anyone any more?
